<?php

namespace App\Controller;

use App\Entity\Booking;
use App\Entity\Category;
use App\Entity\Client;
use App\Entity\Dish;
use App\Entity\Formula;
use App\Entity\Gallery;
use App\Entity\Menu;
use App\Entity\Restaurant;
use App\Entity\Schedule;
use App\Entity\User;
use App\Repository\BookingRepository;
use App\Repository\CategoryRepository;
use App\Repository\DishRepository;
use App\Repository\GalleryRepository;
use App\Repository\MenuRepository;
use App\Repository\RestaurantRepository;
use App\Repository\ScheduleRepository;
use DateTime;
use Doctrine\ORM\EntityManagerInterface;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\IsGranted;
use Symfony\Bridge\Twig\Mime\TemplatedEmail;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Bundle\SecurityBundle\Security;
use Symfony\Component\HttpFoundation\File\Exception\FileException;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\Address;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Serializer\SerializerInterface;
use Symfony\Component\Serializer\Context\Normalizer\ObjectNormalizerContextBuilder;
use Symfony\Component\String\Slugger\SluggerInterface;
use Symfony\Component\Validator\Constraints\File;
use Symfony\Component\Validator\Validator\ValidatorInterface;


#[Route('/api')]
class ApiController extends AbstractController
{
    
    ///////////////////////
    // ADMIN CONTROLLERS //
    ///////////////////////
    
    // Gallery
    ////////////
    #[Route('/gallery', name: 'app_get_gallery', methods: ['GET'])]
    public function gallery(GalleryRepository $galleryRepository, SerializerInterface $serializer): JsonResponse
    {
        $images = $galleryRepository->findAll();
        $responseJson = $serializer->serialize($images, 'json', []);

        return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
    }

    #[Route('/update/image/{id}', name: 'app_update_image', methods: ['POST'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_image(
        Gallery $image,
        SerializerInterface $serializer,
        Request $request,
        EntityManagerInterface $em,
        SluggerInterface $slugger,
        ValidatorInterface $validator
    ): JsonResponse {
        // get CSRF token generated by the twig function
        $submittedToken = $request->request->get('token');
        //proceed if the token is valid
        if ($this->isCsrfTokenValid('image', $submittedToken)) {
            $updateImage = $request->files->get('image');
            $description = $request->get('description');

            // Check if file is an image with a max size 2Mo
            $violations = $validator->validate(
                $updateImage,
                new File([
                    'maxSize' => '2000K',
                    'mimeTypes' => [
                        'image/*'
                    ],
                    'maxSizeMessage' => 'Le fichier doit faire moins de 2Mo',
                    'mimeTypesMessage' => 'Le fichier doit être une image'
                ])
            );
            // if there is an error during validation, send back the error
            if ($violations->count() > 0) {
                return new JsonResponse($serializer->serialize($violations, 'json', []), Response::HTTP_BAD_REQUEST, [], true);
            }

            if ($updateImage) {

                $originalFilename = pathinfo($updateImage->getClientOriginalName(), PATHINFO_FILENAME);
                $safeFilename = $slugger->slug($originalFilename);
                $newFilename = $safeFilename . '-' . uniqid() . '.' . $updateImage->guessExtension();
                try {
                    $updateImage->move(
                        $this->getParameter('image_upload_directory'),
                        $newFilename
                    );

                    $filesystem = new Filesystem();

                    $oldImage = $image->getUrl();
                    $filesystem->remove([$this->getParameter('image_upload_directory') . '/' . $oldImage]);

                    $image->setUrl($newFilename);
                } catch (FileException $e) {
                    // ... handle exception if something happens during file upload
                    $message = [
                        'message' => 'Un problème est servenu lors du chargement de l\'image, veuillez recommencer'
                    ];

                    $messageJson = $serializer->serialize($message, 'json', []);

                    return new JsonResponse($messageJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
                }
            }
            $image->setDescription($description);

            $errors = $validator->validate($image);
            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }

            $em->persist($image);
            $em->flush();
            $content = [
                'message' => 'Changement sauvegardé. '
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/delete/image/{id}', name: 'app_delete_image', methods: ['DELETE'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function delete_image(
        Gallery $image,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('image', $submittedToken)) {
            $imageUrl = $image->getUrl();
            try {
                $filesystem = new Filesystem();

                $filesystem->remove([$this->getParameter('image_upload_directory') . '/' . $imageUrl]);
            } catch (FileException $e) {
                // ... handle exception if something happens during file deletion
                $message = [
                    'message' => 'Un problème est servenu lors de la suppression de l\'image, veuillez recommencer'
                ];

                $messageJson = $serializer->serialize($message, 'json', []);

                return new JsonResponse($messageJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
            }


            $em->remove($image);
            $em->flush();
            $content = [
                'message' => 'Image supprimée. '
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/add/image', name: 'app_add_image', methods: ['POST'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function add_image(
        SerializerInterface $serializer,
        Request $request,
        EntityManagerInterface $em,
        SluggerInterface $slugger,
        ValidatorInterface $validator
    ): JsonResponse {

        $submittedToken = $request->request->get('token');

        if ($this->isCsrfTokenValid('image', $submittedToken)) {
            $image = new Gallery();

            $addImage = $request->files->get('image');
            $description = $request->get('description');
            // Check if file is an image with a max size 2Mo
            $violations = $validator->validate(
                $addImage,
                new File([
                    'maxSize' => '2000K',
                    'mimeTypes' => [
                        'image/*'
                    ],
                    'maxSizeMessage' => 'Le fichier doit faire moins de 2Mo',
                    'mimeTypesMessage' => 'Le fichier doit être une image'
                ])
            );

            if ($violations->count() > 0) {

                return new JsonResponse($serializer->serialize($violations, 'json', []), Response::HTTP_BAD_REQUEST, [], true);
            }

            if ($addImage) {

                $originalFilename = pathinfo($addImage->getClientOriginalName(), PATHINFO_FILENAME);
                $safeFilename = $slugger->slug($originalFilename);
                $newFilename = $safeFilename . '-' . uniqid() . '.' . $addImage->guessExtension();
                try {
                    $addImage->move(
                        $this->getParameter('image_upload_directory'),
                        $newFilename
                    );

                    $image->setUrl($newFilename);
                } catch (FileException $e) {
                    // ... handle exception if something happens during file upload
                    $message = [
                        'message' => $e
                    ];

                    $messageJson = $serializer->serialize($message, 'json', []);

                    return new JsonResponse($messageJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
                }
            }

            $image->setDescription($description);

            $errors = $validator->validate($image);
            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }

            $em->persist($image);
            $em->flush();
            $content = [
                'message' => 'Changement sauvegardé. '
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    // Restaurant Info
    ////////////////////
    #[Route('/restaurant', name: 'app_get_restaurant_info', methods: ['GET'])]
    public function get_restaurant(
        RestaurantRepository $restaurantRepository,
        SerializerInterface $serializer
    ): JsonResponse {
        $restaurant = $restaurantRepository->findAll();
        $context = (new ObjectNormalizerContextBuilder())
            ->withGroups('get_restaurant')
            ->toArray();
        $restaurantJson = $serializer->serialize($restaurant, 'json', $context);
        return new JsonResponse($restaurantJson, Response::HTTP_OK, [], true);
    }

    #[Route('/update/restaurant/{id}', name: 'app_update_restaurant_info', methods: ['PUT'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_restaurant(
        Restaurant $restaurant,
        SerializerInterface $serializer,
        Request $request,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {

        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('restaurant', $submittedToken)) {

            $updateRestaurant = $serializer->deserialize(
                $request->getContent(),
                Restaurant::class,
                'json'
            );
            $restaurant->setAddress($updateRestaurant->getAddress());
            $restaurant->setCity($updateRestaurant->getCity());
            $restaurant->setPhone($updateRestaurant->getPhone());
            $restaurant->setPostCode($updateRestaurant->getPostCode());
            $restaurant->setMaxCapacity($updateRestaurant->getMaxCapacity());

            $errors = $validator->validate($restaurant);
            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($restaurant);
            $em->flush();
            $content = [
                'message' => 'Changement enregistré'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    // Schedule
    /////////////
    #[Route('/schedule', name: 'app_get_schedule', methods: ['GET'])]
    public function get_schedule(
        ScheduleRepository $scheduleRepository,
        SerializerInterface $serializer,
        EntityManagerInterface $em
    ): JsonResponse {
        $schedule = $scheduleRepository->findAll();

        // This part prevent the schedule to be empty or not coherent, like missing days, or several same days or 
        // If the schedule was not created with the fixtures...
        if (count($schedule) < 7) {
            // If the schedule table has less than 7 entries, it gets truncated... 
            $connection = $em->getConnection();
            $plateform = $connection->getDatabasePlatform();
            $connection->executeQuery($plateform->getTruncateTableSQL('schedule', true));

            //... Then filled with dummy values. Those values are the same of the AppFixtures
            $days = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];

            $schedule = array();

            for ($i = 0; $i < count($days); $i++) {
                $schedule[$i] = new Schedule();

                $schedule[$i]->setDay($days[$i]);
                $i <= 4 ? $schedule[$i]->setNoonClosed(false) : $schedule[$i]->setNoonClosed(true);
                $schedule[$i]->setNoonStart(new DateTime('11:00'));
                $schedule[$i]->setNoonEnd(new DateTime('14:00'));
                $i >= 4 && $i < 6 ? $schedule[$i]->setEveningClosed(false) : $schedule[$i]->setEveningClosed(true);
                $schedule[$i]->setEveningStart(new DateTime('17:00'));
                $schedule[$i]->setEveningEnd(new DateTime('21:00'));

                $em->persist($schedule[$i]);
                $em->flush();

            }
            $schedule = $scheduleRepository->findAll();
        }
        $scheduleJson = $serializer->serialize($schedule, 'json', []);

        return new JsonResponse($scheduleJson, Response::HTTP_OK, [], true);
    }

    #[Route('/update/schedule/{id}', name: 'app_update_schedule', methods: ['PUT'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_schedule(
        Schedule $schedule,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em
    ): JsonResponse {

        $requestArray = $request->toArray();
        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('schedule', $submittedToken)) {
            $updateSchedule = $serializer->deserialize(
                $request->getContent(),
                Schedule::class,
                'json'
            );

            // Prevent to save incoherent schedule with start shift hour later than end shift hour
            if ($updateSchedule->getNoonStart() > $updateSchedule->getNoonEnd() || $updateSchedule->getEveningStart() > $updateSchedule->getEveningEnd()) {
                $content = [
                    'message' => 'L\' heure de début ne peut pas être supérieur à l\'heure de fin.'
                ];
                $responseJson = $serializer->serialize($content, 'json', []);
                return new JsonResponse($responseJson, Response::HTTP_BAD_REQUEST, [], true);
            }

            $schedule->setNoonStart($updateSchedule->getNoonStart());
            $schedule->setNoonEnd($updateSchedule->getNoonEnd());
            $schedule->setNoonClosed($updateSchedule->isNoonClosed());
            $schedule->setEveningStart($updateSchedule->getEveningStart());
            $schedule->setEveningEnd($updateSchedule->getEveningEnd());
            $schedule->setEveningClosed($updateSchedule->isEveningClosed());

            $em->persist($schedule);
            $em->flush();
            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    // Category and dishes
    ////////////////////////
    #[Route('/categories', name: 'app_get_categories', methods: ['GET'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function get_categories(
        CategoryRepository $categoryRepository,
        SerializerInterface $serializer,

    ): JsonResponse {
        $category = $categoryRepository->findOrderByRank();
        $context = (new ObjectNormalizerContextBuilder())
            ->withGroups('get_category')
            ->toArray();
        $categoryJson = $serializer->serialize($category, 'json', $context);
        return new JsonResponse($categoryJson, Response::HTTP_OK, [], true);
    }

    #[Route('/update/categories/{id}', name: 'app_update_categories', methods: ['PUT'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_categories(
        Category $category,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {

        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('category', $submittedToken)) {

            $updateCategory = $serializer->deserialize(
                $request->getContent(),
                Category::class,
                'json'
            );


            $category->setName($updateCategory->getName());
            $category->setRankDisplay($updateCategory->getRankDisplay());

            $errors = $validator->validate($category);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }

            $em->persist($category);
            $em->flush();
            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/delete/categories/{id}', name: 'app_delete_categories', methods: ['DELETE'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function delete_categories(
        Category $category,
        Request $request,
        EntityManagerInterface $em,
        SerializerInterface $serializer
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('category', $submittedToken)) {
            $em->remove($category);
            $em->flush();
            $content = [
                'message' => 'Catégorie supprimée. '
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/add/categories', name: 'app_add_categories', methods: ['POST'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function add_categories(
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {

        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('category', $submittedToken)) {
            $updateCategory = $serializer->deserialize(
                $request->getContent(),
                Category::class,
                'json'
            );

            $category = new Category();
            $category->setName($updateCategory->getName());
            $category->setRankDisplay($updateCategory->getRankDisplay());

            $errors = $validator->validate($category);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }

            $em->persist($category);
            $em->flush();
            $content = [
                "message" => "Catégorie ajoutée. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/dishes', name: 'app_get_dishes', methods: ['GET'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function get_dishes(
        DishRepository $dishRepository,
        SerializerInterface $serializer,
        Request $request,
        CategoryRepository $categoryRepository
    ): JsonResponse {

        $page = intval($request->query->get('page'));
        $maxResults = intval($request->query->get('max'));
        $categoryId = intval($request->query->get('category'));

        if ($categoryId) {
            $category = $categoryRepository->find($categoryId);
            $count = count($dishRepository->findBy(['category' => $category]));
            $dishList = $dishRepository->findByCategoryWithPagination($page, $maxResults, $categoryId);
        } else {
            $count = count($dishRepository->findAll());
            $dishList = $dishRepository->findWithPagination($page, $maxResults);
        }

        $dish = [
            'count' => $count,
            'dish' => $dishList
        ];
        $context = (new ObjectNormalizerContextBuilder())
            ->withGroups('get_dishes')
            ->toArray();
        $dishJson = $serializer->serialize($dish, 'json', $context);

        return new JsonResponse($dishJson, Response::HTTP_OK, [], true);
    }

    #[Route('/update/dishes/{id}', name: 'app_update_dishes', methods: ['PUT'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_dishes(
        Dish $dish,
        CategoryRepository $categoryRepository,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('dishes', $submittedToken)) {
            $updateDish = $serializer->deserialize(
                $request->getContent(),
                Dish::class,
                'json'
            );

            $dish->setName($updateDish->getName());
            $dish->setDescription($updateDish->getDescription());
            $dish->setPrice($updateDish->getPrice());


            $content = $request->toArray();
            $idCategory = $content['category'];

            $dish->setCategory($categoryRepository->find($idCategory));

            $errors = $validator->validate($dish);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($dish);
            $em->flush();

            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/add/dishes', name: 'app_add_dishes', methods: ['POST'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function add_dishes(
        CategoryRepository $categoryRepository,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('dishes', $submittedToken)) {
            $updateDish = $serializer->deserialize(
                $request->getContent(),
                Dish::class,
                'json'
            );

            $dish = new Dish();

            $dish->setName($updateDish->getName());
            $dish->setDescription($updateDish->getDescription());
            $dish->setPrice($updateDish->getPrice());

            $content = $request->toArray();
            $idCategory = $content['category'];

            $dish->setCategory($categoryRepository->find($idCategory));

            $errors = $validator->validate($dish);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($dish);
            $em->flush();

            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/delete/dishes/{id}', name: 'app_delete_dishes', methods: ['DELETE'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function delete_dishes(
        Dish $dish,
        Request $request,
        EntityManagerInterface $em,
        SerializerInterface $serializer
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('dishes', $submittedToken)) {
            $em->remove($dish);
            $em->flush();
            $content = [
                'message' => 'Plat supprimé. '
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }


    // Menus and Formulas
    ///////////////////////
    #[Route('/menus', name: 'app_get_menus', methods: ['GET'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function get_menus(
        MenuRepository $menuRepository,
        SerializerInterface $serializer,

    ): JsonResponse {
        $menu = $menuRepository->findAll();
        $context = (new ObjectNormalizerContextBuilder())
            ->withGroups('get_menu_with_formulas')
            ->toArray();
        $menuJson = $serializer->serialize($menu, 'json', $context);
        return new JsonResponse($menuJson, Response::HTTP_OK, [], true);
    }

    #[Route('/update/menus/{id}', name: 'app_update_menus', methods: ['PUT'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_menus(
        Menu $menu,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {

        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('menus', $submittedToken)) {
            $updateMenu = $serializer->deserialize(
                $request->getContent(),
                Category::class,
                'json'
            );


            $menu->setName($updateMenu->getName());

            $errors = $validator->validate($menu);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($menu);
            $em->flush();
            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/delete/menus/{id}', name: 'app_delete_menus', methods: ['DELETE'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function delete_menus(
        Menu $menu,
        Request $request,
        EntityManagerInterface $em,
        SerializerInterface $serializer
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('menus', $submittedToken)) {
            $em->remove($menu);
            $em->flush();
            $content = [
                'message' => 'Menu supprimé. '
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/add/menus', name: 'app_add_menus', methods: ['POST'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function add_menus(
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('menus', $submittedToken)) {
            $updateMenu = $serializer->deserialize(
                $request->getContent(),
                Menu::class,
                'json'
            );

            $menu = new Menu();
            $menu->setName($updateMenu->getName());

            $errors = $validator->validate($menu);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($menu);
            $em->flush();
            $content = [
                "message" => "Catégorie ajoutée. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }


    #[Route('/update/formulas/{id}', name: 'app_update_formulas', methods: ['PUT'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_formulas(
        Formula $formula,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('formulas', $submittedToken)) {
            $updateFormula = $serializer->deserialize(
                $request->getContent(),
                Formula::class,
                'json'
            );

            $formula->setName($updateFormula->getName());
            $formula->setDescription($updateFormula->getDescription());
            $formula->setPrice($updateFormula->getPrice());

            $errors = $validator->validate($formula);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($formula);
            $em->flush();

            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/add/formulas', name: 'app_add_formulas', methods: ['POST'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function add_formulas(
        MenuRepository $menuRepository,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('formulas', $submittedToken)) {
            $updateFormula = $serializer->deserialize(
                $request->getContent(),
                Formula::class,
                'json'
            );

            $formula = new Formula();

            $formula->setName($updateFormula->getName());
            $formula->setDescription($updateFormula->getDescription());
            $formula->setPrice($updateFormula->getPrice());


            $requestArray = $request->toArray();
            $idMenu = $requestArray['menuId'];

            $formula->setMenu($menuRepository->find($idMenu));

            $errors = $validator->validate($formula);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($formula);
            $em->flush();

            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/delete/formulas/{id}', name: 'app_delete_formulas', methods: ['DELETE'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function delete_formulas(
        Formula $formula,
        Request $request,
        EntityManagerInterface $em,
        SerializerInterface $serializer
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('formulas', $submittedToken)) {
            $em->remove($formula);
            $em->flush();
            $content = [
                'message' => 'Formule supprimée. '
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    // Booking
    ////////////
    #[Route('/booking', name: 'app_get_booking', methods: ['GET'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function get_booking(
        BookingRepository $bookingRepository,
        SerializerInterface $serializer,
        Request $request
    ): JsonResponse {

        
        $page = intval($request->query->get('page'));
        $maxResults = intval($request->query->get('max'));
        $name = $request->query->get('name');

        $count = count($bookingRepository->findByName($name));
        $booking = [
            'count' => $count,
            'booking' => $bookingRepository->findWithPagination($page, $maxResults, $name)
        ];

        $bookingJson = $serializer->serialize($booking, 'json', []);
        return new JsonResponse($bookingJson, Response::HTTP_OK, [], true);
    }

    #[Route('/update/booking/{id}', name: 'app_update_booking', methods: ['PUT'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_booking(
        Booking $booking,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('booking', $submittedToken)) {
            $updateBooking = $serializer->deserialize(
                $request->getContent(),
                Booking::class,
                'json'
            );

            $booking->setLastName($updateBooking->getLastName());
            $booking->setAllergies($updateBooking->getAllergies());
            $booking->setPhone($updateBooking->getPhone());
            $booking->setShift($updateBooking->getShift());
            $booking->setDate($updateBooking->getDate());
            $booking->setTime($updateBooking->getTime());
            $booking->setNumber($updateBooking->getNumber());

            $errors = $validator->validate($booking);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($booking);
            $em->flush();

            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/add/booking', name: 'app_add_booking', methods: ['POST'])]
    public function add_booking(
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        ValidatorInterface $validator,
        RestaurantRepository $restaurantRepository,
        BookingRepository $bookingRepository,
        MailerInterface $mailer
    ): JsonResponse {
        $requestArray = $request->toArray();
        $submittedToken = $requestArray['token'];
        if ($this->isCsrfTokenValid('booking', $submittedToken)) {
            $updateBooking = $serializer->deserialize(
                $request->getContent(),
                Booking::class,
                'json'
            );

            $date = date_format($updateBooking->getDate(), 'c');
            $shift = $updateBooking->getShift();
            $number = $updateBooking->getNumber();

            $maxCapacity = $restaurantRepository->getMaxCapacity();

            $seatsTaken = $bookingRepository->getAvailable($date, $shift)[0]['seats'] === null ? 0 : intval($bookingRepository->getAvailable($date, $shift)[0]['seats']);

            $seatsLeft = $maxCapacity - $seatsTaken;

            if ($seatsLeft - $number < 0) {
                $content = [
                    'message' => 'Il \'a plus assez de place pour valider cette réservation'
                ];
                $responseJson = $serializer->serialize($content, 'json', []);
                return new JsonResponse($responseJson, Response::HTTP_BAD_REQUEST, [], true);
            }

            $booking = new Booking();
            $booking->setLastName($updateBooking->getLastName());
            $booking->setFirstName($updateBooking->getFirstName());
            $booking->setEmail($updateBooking->getEmail());
            $booking->setAllergies($updateBooking->getAllergies());
            $booking->setPhone($updateBooking->getPhone());
            $booking->setShift($updateBooking->getShift());
            $booking->setDate($updateBooking->getDate());
            $booking->setTime($updateBooking->getTime());
            $booking->setNumber($updateBooking->getNumber());

            $errors = $validator->validate($booking);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($booking);
            $em->flush();

            // Send confirmation email
            if ($requestArray['email'] !== null) {

                $restaurantInfos = $restaurantRepository->findAll();


                $email = (new TemplatedEmail())
                    ->from(new Address('j.moreschi@outlook.fr', 'Le Quai Antique'))
                    ->to($requestArray['email'])
                    ->subject('Confirmation de réservation')
                    ->htmlTemplate('mail_templates/confirmbooking.html.twig')
                    ->context([
                        'name' => $updateBooking->getLastname(),
                        'date' => date_format($updateBooking->getDate(), 'c'),
                        'time' => date_format($updateBooking->getTime(), 'c'),
                        'tel' => $restaurantInfos[0]->getPhone(),
                    ]);

                $mailer->send($email);
            }

            $content = [
                "message" => "Votre réservation a bien été enregistrée. Vous recevrez sous peu un mail de confirmation"
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/delete/booking/{id}', name: 'app_delete_booking', methods: ['DELETE'])]
    #[IsGranted('ROLE_ADMIN', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function delete_booking(
        Booking $booking,
        Request $request,
        EntityManagerInterface $em,
        SerializerInterface $serializer
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('booking', $submittedToken)) {
            $em->remove($booking);
            $em->flush();
            $content = [
                'message' => 'Réservation supprimée. '
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }


    // Route to get the remaining available seats and the schedule depending on the day
    #[Route('/booking/getavailable', name: 'app_booking_available', methods: ['GET'])]
    public function get_booking_available(
        BookingRepository $bookingRepository,
        RestaurantRepository $restaurantRepository,
        ScheduleRepository $scheduleRepository,
        Request $request,
        SerializerInterface $serializer
    ): JsonResponse {

        $date = $request->query->get('date');
        $shift = $request->query->get('shift');

        $day = $scheduleRepository->getScheduleByDate($date, $shift);

        $maxCapacity = $restaurantRepository->getMaxCapacity();

        $seatsTaken = $bookingRepository->getAvailable($date, $shift)[0]['seats'] === null ? 0 : intval($bookingRepository->getAvailable($date, $shift)[0]['seats']);

        $seatsLeft = $maxCapacity - $seatsTaken;
        $response = [
            'seatsLeft' => $seatsLeft,
            'shiftStart' => $day['start'],
            'shiftEnd' => $day['end'],
            'shiftClosed' => $day['closed']

        ];

        $responseJson = $serializer->serialize($response, 'json', []);
        return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
    }

    // Client Account and Profil
    ///////////////////////////
    #[Route('/get/client/{id}', name: 'app_get_client', methods: ['GET'])]
    #[IsGranted('ROLE_USER', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function get_client(
        User $user,
        SerializerInterface $serializer
    ): JsonResponse {

        $email = $user->getEmail();

        $response = [
            'email' => $email
        ];

        $responseJson = $serializer->serialize($response, 'json', []);

        return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
    }

    #[Route('/update/client/{id}', name: 'app_update_client', methods: ['PUT'])]
    #[IsGranted('ROLE_USER', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_client(
        User $user,
        Request $request,
        EntityManagerInterface $em,
        UserPasswordHasherInterface $userPasswordHasher,
        SerializerInterface $serializer,
        Security $security,
        ValidatorInterface $validator
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('profil', $submittedToken)) {
            $currentUser = $security->getUser();
            $requestArray = $request->toArray();
            $email = $requestArray['email'];
            $newPassword = $requestArray['password'];
            $verifPwd = $requestArray['verifPwd'];

            // Verify if the current user is trying to make update on his account
            if ($currentUser !== $user) {
                $content = [
                    'message' => 'Vous ne pouvez effectuer de modification uniquement sur votre compte'
                ];
                $responseJson = $serializer->serialize($content, 'json', []);

                return new JsonResponse($responseJson, Response::HTTP_FORBIDDEN, [], true);
            }

            // If the current password is Okay
            if ($userPasswordHasher->isPasswordValid($user, $verifPwd)) {

                if ($email) {
                    $user->setEmail($email);
                }

                if ($newPassword) {
                    $user->setPassword(
                        $userPasswordHasher->hashPassword(
                            $user,
                            $newPassword
                        )
                    );
                }

                $errors = $validator->validate($user);

                if ($errors->count() > 0) {
                    return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
                }

                $em->persist($user);
                $em->flush();

                $content = [
                    'message' => "Changements effectués"

                ];
                $responseJson = $serializer->serialize($content, 'json', []);

                return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
            } else {
                $content = [
                    'message' => 'Veuillez entrer votre ancien mot de passe pour valider les changements'

                ];
                $responseJson = $serializer->serialize($content, 'json', []);

                return new JsonResponse($responseJson, Response::HTTP_FORBIDDEN, [], true);
            }
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/delete/client/{id}', name: 'app_delete_client', methods: ['DELETE'])]
    #[IsGranted('ROLE_USER', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function delete_client(
        User $user,
        Request $request,
        UserPasswordHasherInterface $userPasswordHasher,
        EntityManagerInterface $em,
        SerializerInterface $serializer,
        Security $security
    ): JsonResponse {


        $requestArray = $request->toArray();
        $password = $requestArray['password'];
        $currentUser = $security->getUser();
        $isAdmin = in_array('ROLE_ADMIN', $user->getRoles());
        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('profil', $submittedToken)) {

            if ($isAdmin) {
                $content = [
                    'message' => 'Le compte administrateur ne peut pas être supprimé'
                ];
                $responseJson = $serializer->serialize($content, 'json', []);

                return new JsonResponse($responseJson, Response::HTTP_FORBIDDEN, [], true);
            }
            // Verify if the current user is trying to delete his own account
            if ($currentUser !== $user) {
                $content = [
                    'message' => 'Vous ne pouvez effectuer de modification uniquement sur votre compte'
                ];
                $responseJson = $serializer->serialize($content, 'json', []);

                return new JsonResponse($responseJson, Response::HTTP_FORBIDDEN, [], true);
            }

            if ($userPasswordHasher->isPasswordValid($user, $password)) {
                $em->remove($user);
                $em->flush();

                $security->logout(false);
                $content = [
                    'message' => "Client supprimé"

                ];
                $responseJson = $serializer->serialize($content, 'json', []);

                return new JsonResponse($responseJson, Response::HTTP_OK, [], true);
            } else {
                $content = [
                    'message' => 'Veuillez entrer votre ancien mot de passe pour valider la suppression'

                ];
                $responseJson = $serializer->serialize($content, 'json', []);

                return new JsonResponse($responseJson, Response::HTTP_FORBIDDEN, [], true);
            }
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }

    #[Route('/update/profil/{id}', name: 'app_update_profil', methods: ['PUT'])]
    #[IsGranted('ROLE_USER', message: 'Vous n\'avez pas les droits suffisants pour effectuer cette action')]
    public function update_profil(
        Client $client,
        Request $request,
        SerializerInterface $serializer,
        EntityManagerInterface $em,
        Security $security,
        ValidatorInterface $validator
    ): JsonResponse {
        $requestArray = $request->toArray();

        $submittedToken = $requestArray['token'];

        if ($this->isCsrfTokenValid('profil', $submittedToken)) {
            $updateClient = $serializer->deserialize(
                $request->getContent(),
                Client::class,
                'json'
            );

            $user = $client->getUserId();
            $currentUser = $security->getUser();

            if ($currentUser !== $user) {
                $content = [
                    'message' => 'Vous ne pouvez effectuer de modification uniquement sur votre compte'
                ];
                $responseJson = $serializer->serialize($content, 'json', []);

                return new JsonResponse($responseJson, Response::HTTP_FORBIDDEN, [], true);
            }

            $client->setLastname($updateClient->getLastname());
            $client->setFirstname($updateClient->getFirstname());
            $client->setAllergies($updateClient->getAllergies());
            $client->setPhone($updateClient->getPhone());
            $client->setNumber($updateClient->getNumber());

            $errors = $validator->validate($client);

            if ($errors->count() > 0) {
                return new JsonResponse($serializer->serialize($errors, 'json'), JsonResponse::HTTP_BAD_REQUEST, [], true);
            }
            $em->persist($client);
            $em->flush();

            $content = [
                "message" => "Changement sauvegardé. "
            ];

            $contentJson = $serializer->serialize($content, 'json', []);

            return new JsonResponse($contentJson, Response::HTTP_OK, [], true);
        } else {
            $content = [
                'message' => 'Une erreur est survenue'
            ];
            $responseJson = $serializer->serialize($content, 'json', []);
            return new JsonResponse($responseJson, Response::HTTP_INTERNAL_SERVER_ERROR, [], true);
        }
    }
}
